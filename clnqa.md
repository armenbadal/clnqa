# Common Lisp։ հարցեր ու պատասխաններ

__Հարց։__ _Ի՞նչ լեզու է Common Lisp֊ը։_

Common Lisp֊ը _ծրագրավորվող_ ծրագրավորման լեզու է։ Այն առավել հայտնի է իր առավելագույն ճկունությամբ։ Common Lisp֊ը ընդհանուր նշանակության, բազմանպատակ, կոմպիլյացվող և ինտերպրետացվող ծրագրավորման լեզու է, որը սերում է 1950֊ականներին Ջոն ՄակՔարթիի ստեղծած LISP լեզվից և հանդիսանում է ծրագրավորման լեզուների LISP ընտանիքի _ստանդարտացված_ ներկայացուցիչ։ Այլ կերպ ասած՝ Common Lisp֊ը _լուրջ_ լեզու է։ Այն հնարվարություն է տալիս ծրագրավորել ինչպես _ֆունկցիոնալ_, այնպես էլ _պրոցեդուրային_ և _օբյեկտներին կողմնորոշված_ մեթոդներով։ Լեզվի 1994 թ․֊ին ընդունված ստանդարտը պարունակում է ավելի քան 1000 _ֆունկցիաներ_, _մակրոներ_, _հատուկ կառուցվածքներ_, _սիմվոլներ_ և այլն։ Լեզվի առանձնապես նշանավոր հատկություններից են ցիկլերի կազմակերպմա `loop` մակրոսը, տեքստի ֆորմատավորման `format` գործողությունը և օբյեկտներին կոմնորոշված ծրագրավորման _CLOS_ համակարգը։


__Հարց։__ _Ի՞նչ իրականացումներ են մատչելի_։

Common Lisp լեզվի համար այսօր կան բավականին հաջող _ազատ_ իրականացումներ։ Դրանցից են [_SBCL_](http://www.sbcl.org/)֊ը, [_Clozure CL_](http://ccl.clozure.com/)֊ը, [_CMUCL_](http://www.cons.org/cmucl/)֊ը, [_ECL_](https://common-lisp.net/project/ecl/)֊ը և [_ABCL_](https://common-lisp.net/project/armedbear/)֊ը։


__Հարց։__ _Ի՞նչ աշխատանքային միջավայրն օգտագործել։_

Ես սովորություն ունեմ Լիսպ ծրագրերը խմբագրել GNU/Emacs խմբագրիչով և դրանք կատարել հրամանային տողից՝ SBCL֊ի օգնությամբ։ Բայց նոր սովորողներին միշտ խորհուրդ եմ տալիս օգտագործել [LispBox](https://common-lisp.net/project/lispbox/) փաթեթը։ Այն ներառում է GNU/Emacs խմբագրիչը, Common Lisp լեզվի CMUCL իրականացումը, գրադարանների կառավարման Quicklisp համակարգը և Emacs֊ի մեջ Լիսպ իրականացման աշխատանքն ապահովող SLIME փաթեթը։ LispBox փաթեթը մատչելի է և՛ GNU/Linux, և՛ Mac OS, և՛ Windows օպերացիոն համակարգերի համար։ 


__Հարց։__ _Ինչպե՞ս կատարել ֆայլում գրված ծրագիրը։_

Common Lisp֊ի (մեծամասամբ նաև Lisp լեզվի այլ տարբերակների) հետ աշխատանքը սկսվում է _երկխոսության_ REPL (read-eval-print loop) ռեժիմից. Լիսպ համակարգը կարդում է ծրագրավորողի ներմուծած արտահայտությունները, ապա հաշվարկում է դրանք և արտածում արդյունքները։ Ահա REPL֊ի հետ «երկխոսության» մի հատված․

````lisp
* (+ 1 2 3 4)
10
* pi
3.141592653589793d0
* (> 3 4)
NIL
* _ 
````

Այստեղ `*`֊ը երկխոսության _հրավերքն_ է, որի դիմաց պետք է գրել հաշվարկման ենթակա արտահայտությունը։ (Common Lisp֊ի տարբեր իրականացումներում հրավերքի տեսքը կարող է տարբեր լինել։)

Դիցուք այժմ `example0.lisp` ֆայլում գրված է տրված `n` բնական թվի ֆակտորիալը հաշվող հետևյալ ֆունկցիան․

````lisp
(defun factorial (n)
  "Հաշվում է n թվի ֆակտորիալը սովորական ռեկուրսիվ եղանակով։"
    (if (= n 1)
        1
        (* n (factorial (1- n)))))
````

Այս ֆունկցիան ինչ֊որ արգումենտով կատարելու համար պետք է նախ՝ ֆայլը բեռնել Common Lisp կատարման միջավայր։ Դա արվում է `load` գործողությամբ։

````lisp
(load "example0.lisp")
````

Նույն արդյունքը կարելի է ստանալ, եթե, օրինակ, SBCL֊ի հրամանային տողից `example0.lisp` ֆայլը Լիսպ համակարգին փոխանցվի հրամանային տողի `--load` բանալիով։ Երբ հրամանային տողում գրում ենք `sbcl --load example0.lisp`, ապա գործարկվում է Լիսպ համակարգը և հերթականությամբ հաշվարկվում են `example0.lisp` ֆայլում գրված արտահայտությունները։ 

Երբ Լիսպը գործարկված է և կատարման համակարգ է բեռնված ծրագիրը պարունակող ֆայլը, արդեն կարելի է `factorial` ֆունկցաին կիրառել որևէ արգումենտի նկատմամբ և տեսնել արդյունքը։ Օրինակ․

````lisp
(factorial 40)       ; => 815915283247897734345611269596115894272000000000
````

Եթե այլ բան հարկավոր չէ, Լիսպ համակարգը կարելի է լքել `quit` գործողությամբ։

Եթե `example0.lisp` ֆայլում `factorial` ֆունկցիայի սահմանումից անմիջապես հետո գրենք հետևյալ արտահայտությունները․

````lisp
(print (factorial 40))
(terpei)
````

ապա կարող ենք վերը նշված գործողությունները կատարել հրամանային տողի `sbcl --load example0.lisp --quit` հրամանով։ Սա գերծարկում է Լիսպը, բեռնում է `example0.lisp` ֆալյլը, հաջորդաբար հաշվարկում է դրանում գրված արտահայտությունները, ապա դուրս է գալիս Լիսպ համակարգից։


__Հարց։__ _Ինչպե՞ս տեսնել Common Lisp իրականացման անունն ու տարբերակը։_

Բացի այն, որ Լիսպ֊համակարգի գործարկումից հետո արտածվում են համապատասխան տեղեկությունները, Common Lisp ստանդարտը հնարավորություն է տալիս իրականացման անունը ստանալ `lisp-implementation-type` գործողությամբ, իսկ իրականացման տարբերակը՝ `lisp-implementation-version` գործողությամբ։

````lisp
(lisp-implemetation-type)      ; => "Clozure Common Lisp"
(lsip-implementation-version)  ; => "Version 1.11-r16635  (LinuxX8664)"
````


__Հարց։__ _Ի՞նչ տեսքով են գրառվում Լիսպ ծրագրերը։_

Լիսպ ընտանիքի բոլոր լեզուներում _ծրագրերն_ ու _տվյալները_ գրառվում են միատեսակ՝ _S֊արտահայտությունների_ (symbolic expression) տեսքով։ Սիմվոլիկ արտահայտությունը կա՛մ անտրոհելի սիմվոլ՝ _ատոմ_ է, կա՛մ կլոր փակագծերում պարփակված ցուցակ է, որի տարրերը ատոմներ և S֊արտահայտություններ են։ Ահա S֊արտահայտությունների մի քանի օրինակ․

````lisp
x0                ; ատոմ (իդենտիֆկատոր)
777               ; ատոմ (ամբողջ թիվ)
3.415             ; ատոմ (իրական թիվ)
(a 1 2.4)         ; պարզ ցուցակ
((e f) 77 (x 8))  ; ներդրված ցուցակ
````

Լիսպ ծրագիրը S-արտահայտությունների միջոցով գրառված տեքստ է, որը կարող է պարունակել _ֆունկցիաների_, _մակրոների_, _փոփոխականների_, _դասերի_ և այլ օբյեկտների սահմանումներ։


__Հարց։__ _Ինչպե՞ս են գրվում և հաշվարկվում մաթեմատիկական արտահայտությունները։_

Ինչպես և մնացած ամեն ինչ, մաթեմատիկական արտահայտություններն էլ Լիսպ լեզվում գրառվում են S֊արտահայտությունների միջոցով։ Այս դեպքում, սակայն, S֊արտահայտության առաջին տարրը համարվում է _գործողություն_, իսկ մյուսները՝ _արգումենտներ_։ Օրինակ, եթե `a`֊ն, `b`֊ն և `c`֊ն քառակուսային հավասարման գործակիցներն են, ապա այդ հավասարման որոշիչը (դետերմինանտ) հաշվարկող մաթեմատիկական արտահայտությունը կունենա հետևյալ տեսքը․

````lisp
(- (expt b 2) (* 4 a c))
````

Այստեղ `-`, `expt` և `*` սոիմվոլները գործողություններ են, համապատասխանաբար՝ հանում, աստիճանի բարձրացում և բազմապատկում։


__Հարց։__ _Ինչպե՞ս են կառուցվում ցուցակները։_

Ծրագրերում ցուցակներ կարելի է կառուցել `list` և `cons` գործողություններով։ `list`֊ը ցուցակ է կառուցում իր արգումենտներում տրված արտահայտությունների արժեքներից։ Եթե որևէ արգումենտ տրված չէ՝ կառուցվում է դատարկ ցուցակ՝ `()`։ Օրինակ․

````lisp
(list)                       ; => ()
(list (+ 1 2 3) 7 (* 4 5))   ; => (6 7 20)
````

`cons` գործողությունը տրված տարրը կցում է տրված ցուցակի սկզբից։ Օրինակ․

````lisp
(cons 6 '(1 2 3 4 5))   ; => (6 1 2 3 4 5)
(cons 7 '())            ; => (7)
````


__Հարց։__ _Ինչպե՞ս առանձնացնել ցուցակի մասերը (գլուխը, պոչը և այլն)։_

Ցուցակը տրոհելու համար հիմնականում օգտագործվում են `car` և `cdr` գործողությունները։ `car`֊ը վերադարձնում է ցուցակի առաջին տարրը՝ _գլուխը_, իսկ `cdr`֊ը՝ առաջինից բացի մյուս տարրերի ցուցակը՝ _պոչը_։ Ահա այսպես․

````lisp
(car '(a b c d))    ; => a
(cdr '(a b c d))    ; => (b c d)
````

Հարմարության համար նախատեսված են նաև `car` ու `cdr` գործողությունների կոմբինացիաներ․ `caar`, `cadr`, `caadr`, `cddar` և այլն։ Ընդհանուր դեպքում՝ `c????r` տեսքի, որտեղ `?` նիշերի փոխարեն կարող է լինել `a` և `d` տառերի մեկից մինչև չորս երկարությամբ հաջորդականություն։ Այդ հաջորդականության մեջ `a` տառը ցուցյ է տալիս `car` գործողության կիրառությունը, իսկ `d` տառը՝ `cdr` գործողության։ Օրինա․

````lisp
(cadr '(a b c d e))         ; => b
(car (cdr '(a b c d e)))    ; => b
(caar '((a b) c d))         ; => a
(car (car '((a b) c d)))    ; => a
````


__Հարց։__ _Ինչպե՞ս առանձնացնել ցուցակի առաջին `n` տարրրերը։_

Անդրադարձ (ռեկուրսիվ) ֆունկցիան ունի երկու պարամետր՝ `l` ցուցակը և անջատվելիք տարրերի `n` քանակը։ Ռեկուրսիան կազմակերպվում է ըստ `n`֊ի։ Եթե `n`֊ը զրո է կամ ցուցակը դատարկ է, ապա ռեկուրսիան ավարտվում է և ֆունկցիան վերադարձնում է դատարկ ցուցակ՝ `'()`։ Հակառակ դեպքում `l`֊ի առաջին տարրը կցվում է `l`-ի պոչից `n-1` հատ անջատված տարրերի սկզբից։

````lisp
(defun first-n (l n)
    (if (or (zerop n) (endp l))
        '()
        (cons (car l) (first-n (cdr l) (1- n)))))
````

Ահա նաև մի քանի օրինակ․

````lisp
(first-n '(1 2 3 4 5 6 7) 3)   ; => (1 2 3)
(first-n '(1 2 3 4 5 6 7) 2)   ; => (1 2)
(first-n '(1 2 3 4 5 6 7) 10)  ; => (1 2 3 4 5 6 7)
(first-n '() 10)               ; => NIL
````


__Հարց։__ _Ինչպե՞ս է սահմանվում սովորական ֆունկցիան։_

«Սովորական» (գլոբալ) ֆունկցիան սահմանվում է `defun` գործողության միջոցով։ `defun`֊ին պետք է փոխանցել ֆունկցիայի անունը, պարամետրերի ցուցակը և մարմինը ձևավորող արտահայտությունների հաջորդականությունը։ Օրինակ, աշխարհին հայերեն, ռուսերեն և իտալերեն ողջունող ֆունկցիայի սահմանումը կարող է լինել այսպիսին․

````lisp
(defun hello ()
    (princ "Ողջո՜ւյն, աշխարհ։ ")
    (princ "Привет, мир! ")
    (princ "Ciao, mondo!"))
````

Այս ֆունկցիայի անունը `hello` է, պարամետրերի ցուցակը դատարկ է՝ `()`, իսկ մարմինկ բաղկացած է երեք լեզուներոց տեքստն արտածող `princ` գործողություններից։

Եթե անհրաժեշտ է սահմանել


__Հարց։__ _Ինչպե՞ս է սահմանվում ոչ֊պարտադիր պարամետրերով ֆունկցիան։_

Ֆուկցայի պարամետրերի ցուցակը սահմանելիս `&optional` ծառայողական բառից հետո թվարկված պարամետրերը համարվում են _ոչ֊պարտադիր_։ Օրինակ, հետևյալ `f` ֆունկցիայում `x` պարամետրը պարտադիր է, իսկ `y`֊ը և `z`֊ը՝ ոչ։

````lisp
(defun f(x &optional y z)
    (list x y z))
````

Եթե ոչ֊պարտադիր պարամետրերով ֆունկցիան կանչվում է միայն պարտադիր պարամետրերի արժեքներով, ապա չտրված պարամետրերն ընդունում են `nil` արժեքը։ Ահա `f` ֆունկցիայի կիրառման մի քանի օրինակներ․

````lisp
(f 1)         ; => (1 nil nil)
(f 2 3)       ; => (2 3 nil)
(f 4 5 6)     ; => (4 5 6)
````

Ոչ֊պարտադիր պարամետրին կարելի է տալ _լռելության արժեք_, որն օգտագործվում է այն դեպքում, երբ ֆունկցիան կանչելի տվյալ պարամետրի արժեքը տրված չէ։ Օրինակ, հեետևյալ `h` ֆունկցիան սահմանված է `777` արժեքն ունեցող `y` ոչ֊պարտադիր պարամետրով․

````lisp
(defun h(x &optional (y 777))
    (list x y))
(h 22)       ; => (22 777)
(h 22 888)   ; => (22 888)
````


__Հարց։__ _Ինչպե՞ս է սահմանվում անվանված պարամետրերով ֆունկցիան։_

Անվանված պարամետրերով ֆունկցիա սահմանելու համար պարամետրերի ցուցակում օգտագործվում է `&key` ծառայողական բառը։ Երբ ֆունկցիան սահմանված է անվանված պարամետրերով, դրա կիրառության ժամանակ պետք է տալ նաև պարամետրի անունը։ Օրինակ, 


__Հարց։__ _Ինչպե՞ս սահմանել վարիադիկ ֆունկցիա։_

TODO


__Հարց։__ _Ինչպե՞ս սահմանել լոկալ ֆունկցիա։_

Ֆունկցիայի ներսում _լոկալ_ ֆունկցիան սահմանվում է `flet` և `labels` կառուցվածքներով։ `flet`֊ով սահմանված ֆունկցիան չի կարող կանչել ինքն իրեն, կամ նույն իր մակարդակում սահմանված մի այլ ֆունկցիայի։ `flet`֊ի միջոցով սահմանվում են 

Եթե հարկավոր են ռեկուրսիվ լոկալ ֆունկցիաներ, ապա օգտագործվում է `labels` կառուցվածքը։ Օրինակ, ցուցկը շրջող `reverse-it` ֆունկցիան սահմանելիս շատ հարմար է նրա ներսում սահմանել _վերջին կանչի ռեկուրսիայով_ լոկալ օժանդակ ֆունկցիա․

````lisp
(defun reverse-it (ls)
    (labels ((reverse-rec (l r)
        (if (endp l)
            r
            (reverse-rec (cdr l) (cons (car l) r)))))
        (reverse-rec ls '())))
````


__Հարց։__ _Ինչպե՞ս սահմանել և օգտագործել անանուն ֆունկցիան։_

TODO


__Հարց։__ _Ինչպե՞ս սահմանել գլոբալ հաստատուն։_

Գլոբալ հաստատունը, որի անունը, ի դեպ, ընդունված է սկսել և ավարտել `+` նիշով, սահմանվում է `defconstant` գործողությամբ։ Սա ստանում է հաստատունի անունը, արժեքը և ոչ֊պարտադիր նկարագրության տող։ Օրինակ․

````lisp
(defconstant +size+ 2048)   ; ինչ֊որ չափ ցույց տվող հաստատուն
(defconstant +name+ "Արմեն"
    "Իմ անունը որպես գլոբալ հաստատուն")
````


__Հարց։__ _Ինչպե՞ս սահմանել գլոբալ (դինամիկ) փոփոխական։_

Գլոբալ փոփոխականներ սահմանելու համար նախատեսված են `defvar` և `defparameter` գործողությունները։ Սրանք երկուսն էլ կատարման միջավայր են ներմուծում նոր անուն՝ դրան վերագրելուվ տրված սկզբնական արժեքը։ 


__Հարց։__ _Ինչպե՞ս ստուգել ֆայլի գոյությունը։_

`probe-file` ֆունկցիան տրված ֆայլի անունի համար վերադարձնում է համապատասխան `pathnam` նկարագրիչը, եթե ֆայլը գոյություն ունի։ Հակառակ դեպքում՝ վերադարձնում է `nil`։ Օրինակ․

````lisp
(probe-file "clnqa.md")  ; => #P"/home/armenba/Documents/clnqa/clnqa.md"
(probe-file "what.txt")  ; => nil
````


__Հարց։__ _Ինչպե՞ս տող առ տող կարդալ տեքստային ֆայլը։_

Տեքստային ֆայլից մեկ տող է կարդում `read-line` ֆունկցիան, որի առաջին արգումենտում պետք է տալ ֆայլային հոսքը։ Օրինակ, հետևյալ կոդը կարդում ու արտածում է `test0.txt` ֆայլի առաջին տողը․

````lisp
(with-open-file (inp "test0.txt")
    (print (read-line inp)))
````

Ֆայլը տող առ տող կարդալու համար կարելի է `read-line` գործողությունը կանչել ցիկլի մեջ։ Օրինակ, `loop` ցիկլի օգտագործմամբ․

````lisp
(with-open-file (inp "test0.txt")
    (loop for line = (read-line inp nil nil)
          until (nullp line)
          do (print line)))
````

Այստեղ `read-line`֊ի երկրորդ արգումենտում տրված `nil` արժեքը ցույց է տալիս, որ ֆայլի վերջին հասնելիս պետք է վերադարձնել `read-line`֊ի երրորդ արգումենտում տրված արժեքը (այս դեպքում՝ նորից `nil`)։ Եթե `read-line`֊ի երկրորդ արգումենտում `nil`֊ից տարբեր արժեք է, ապա, ֆայլի վերջին հասնելիս, գեներացվում է սխալ։

