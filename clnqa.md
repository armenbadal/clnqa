# Common Lisp։ հարցեր ու պատասխաններ

__Հարց։__ Ի՞նչ լեզու է Common Lisp֊ը։

Common Lisp֊ը _լուրջ_ լեզու է։ Իսկապես։ Ես երկար որոնեցի այն բառը կամ արտահայտությունը, որով ամենաճշգրիտը կբնութագրեի այս լեզուն, ու կարծում եմ, որ «լուրջ» բառը ամենահարմարն է։ Այն ընդհանուր նշանակության, բազմանպատակ ծրագրավորման լեզու է, սերում է 1950֊ականների Ջոն ՄակՔարթիի ստեղծած Լիսպ լեզվից և հանդիսանում է Լիսպ ընտանիքի _ստանդարտացված_ ներկայացուցիչ։ Common Lisp լեզուն հնարվարություն է տալիս ծրագրավորել ինչպես _ֆունկցիոնալ_, այնպես էլ _պրոցեդուրային_ և _օբյեկտներին կողմնորոշված_ մեթոդներով։ Լեզվի 1994 ստանդարտը պարունակում է ավելի քան 1000 _ֆունկցիաներ_, _մակրոներ_, _հատուկ կառուցվածքներ_, _սիմվոլներ_ և այլն։


__Հարց։__ Ի՞նչ իրականացումներ են մատչելի։

Երբ ասում են «մատչելի իրականացում» ես հասկանում եմ բաց կոդով և անվճար տարածվող իրականացումները։ Common Lisp լեզվի համար այսօր կան բավականին հաջող _մատչելի_ իրականացումներ, օրինակ, [_SBCL_](http://www.sbcl.org/)֊ը, [_Clozure CL_](http://ccl.clozure.com/)֊ը կամ [_ABCL_](https://common-lisp.net/project/armedbear/)֊ը։


__Հարց։__ Ինչպե՞ս կատարել ֆայլում գրված ծրագիրը։

Դիցուք, `example0.lisp` ֆայլում գրված է տրված `n` բնական թվի ֆակտորիալը հաշվող հետևյալ ֆունկցիան․

````lisp
(defun factorial (n)
  "Հաշվում է n թվի ֆակտորիալը սովորական ռեկուրսիվ եղանակով։"
    (if (= n 1)
        1
        (* n (factorial (1- n)))))
````

Այս ֆունկցիան ինչ֊որ արգումենտով կատարելու համար պետք է նախ՝ ֆայլը բեռնել Common Lisp կատարման միջավայր։ Դա արվում է `load` գործողությամբ։

````lisp
(load "example0.lisp")
````

Այնուհետև արդեն `factorial` ֆունկցաին կիրառել որևէ արգումենտի նկատմամբ։ Օրինակ․

````lisp
(factorial 100)       ; => 
````


__Հարց։__ Ինչպե՞ս տեսնել Common Lisp իրականացման անունն ու տարբերակը։

Բացի այն, որ Լիսպ֊համակարգի գործարկումից հետո արտածվում են համապատասխան տեղեկությունները, Common Lisp ստանդարտը հնարավորություն է տալիս իրականացման անունը ստանալ `lisp-implementation-type` գործողությամբ, իսկ իրականացման տարբերակը՝ `lisp-implementation-version` գործողությամբ։

````lisp
(lisp-implemetation-type)      ; => "Clozure Common Lisp"
(lsip-implementation-version)  ; => "Version 1.11-r16635  (LinuxX8664)"
````


__Հարց։__ Ի՞նչ աշխատանքային միջավայրն օգտագործել։

Ես սովորություն ունեմ Լիսպ ծրագրերը խմբագրել GNU/Emacs խմբագրիչով և դրանք կատարել գրամանային տողից՝ SBCL֊ի օգնությամբ։ Բայց նոր սովորողներին միշտ խորհուրդ եմ տալիս օգտագործել Lisp in a Box փաթեթը։ Այն ներաջում է GNU/Emacs խմբագրիչը, Common Lisp լեզվի CMU CL իրականացումը, գրադարանների կառավարման Quicklisp համակարգը և Emacs֊ի մեջ Լիսպ իրականացման աշխատանքն ապահովող SLIME փաթեթը։ Lisp in a Box փաթեթը մատչելի է և՛ GNU/Linux, և՛ Mac OS, և՛ Windows օպերացիոն համակարգերի համար։ 


__Հարց։__ Ի՞նչ տեսքով են գրառվում Լիսպ ծրագրերը։

Լիսպ ընտանիքի բոլոր լեզուներում _ծրագրերն_ ու _տվյալները_ գրառվում են միատեսակ՝ _S֊արտահայտությունների_ (symbolic expression) տեսքով։ Սիմվոլիկ արտահայտությունը կա՛մ անտրոհելի սիմվոլ՝ _ատոմ_ է, կա՛մ կլոր փակագծերում պարփակված ցուցակ է, որի տարրերը ատոմներ և S֊արտահայտություններ են։ Ահա S֊արտահայտությունների մի քանի օրինակ․

````lisp
x0                ; ատոմ (իդենտիֆկատոր)
777               ; ատոմ (ամբողջ թիվ)
3.415             ; ատոմ (իրական թիվ)
(a 1 2.4)         ; պարզ ցուցակ
((e f) 77 (x 8))  ; ներդրված ցուցակ
````

Լիսպ ծրագիրը S-արտահայտությունների միջոցով գրառված տեքստ է, որը կարող է պարունակել _ֆունկցիաների_, _մակրոների_, _փոփոխականների_, _դասերի_ և այլ օբյեկտների սահմանումներ։


__Հարց։__ Ինչպե՞ս են գրվում և հաշվարկվում մաթեմատիկական արտահայտությունները։

Ինչպես և մնացած ամեն ինչ, մաթեմատիկական արտահայտություններն էլ Լիսպ լեզվում գրառվում են S֊արտահայտությունների միջոցով։ Այս դեպքում, սակայն, S֊արտահայտության առաջին տարրը համարվում է _գործողություն_, իսկ մյուսները՝ _արգումենտներ_։ Օրինակ, եթե `a`֊ն, `b`֊ն և `c`֊ն քառակուսային հավասարման գործակիցներն են, ապա այդ հավասարման որոշիչը (դետերմինանտ) հաշվարկող մաթեմատիկական արտահայտությունը կունենա հետևյալ տեսքը․

````lisp
(- (expt b 2) (* 4 a c))
````

Այստեղ `-`, `expt` և `*` սոիմվոլները գործողություններ են, համապատասխանաբար՝ հանում, աստիճանի բարձրացում և բազմապատկում։


__Հարց։__ Ինչպե՞ս են կառուցվում ցուցակները։

Ծրագրերում ցուցակներ կարելի է կառուցել `list` և `cons` գործողություններով։ `list`֊ը ցուցակ է կառուցում իր արգումենտներում տրված արտահայտությունների արժեքներից։ Եթե որևէ արգումենտ տրված չէ՝ կառուցվում է դատարկ ցուցակ՝ `()`։ Օրինակ․

````lisp
(list)                       ; => ()
(list (+ 1 2 3) 7 (* 4 5))   ; => (6 7 20)
````

`cons` գործողությունը տրված տարրը կցում է տրված ցուցակի սկզբից։ Օրինակ․

````lisp
(cons 6 '(1 2 3 4 5))   ; => (6 1 2 3 4 5)
(cons 7 '())            ; => (7)
````


__Հարց։__ Ինչպե՞ս առանձնացնել ցուցակի մասերը (գլուխը, պոչը և այլն)։

Ցուցակը տրոհելու համար հիմնականում օգտագործվում են `car` և `cdr` գործողությունները։ `car`֊ը վերադարձնում է ցուցակի առաջին տարրը՝ _գլուխը_, իսկ `cdr`֊ը՝ առաջինից բացի մյուս տարրերի ցուցակը՝ _պոչը_։ Ահա այսպես․

````lisp
(car '(a b c d))    ; => a
(cdr '(a b c d))    ; => (b c d)
````

Հարմարության համար նախատեսված են նաև `car` ու `cdr` գործողությունների կոմբինացիաներ․ `caar`, `cadr`, `caadr`, `cddar` և այլն։ Ընդհանուր դեպքում՝ `c????r` տեսքի, որտեղ `?` նիշերի փոխարեն կարող է լինել `a` և `d` տառերի մեկից մինչև չորս երկարությամբ հաջորդականություն։ Այդ հաջորդականության մեջ `a` տառը ցուցյ է տալիս `car` գործողության կիրառությունը, իսկ `d` տառը՝ `cdr` գործողության։ Օրինա․

````lisp
(cadr '(a b c d e))         ; => b
(car (cdr '(a b c d e)))    ; => b
(caar '((a b) c d))         ; => a
(car (car '((a b) c d)))    ; => a
````


__Հարց։__ Ինչպե՞ս առանձնացնել ցուցակի առաջին `n` տարրրերը։

Անդրադարձ (ռեկուրսիվ) ֆունկցիան ունի երկու պարամետր՝ `l` ցուցակը և անջատվելիք տարրերի `n` քանակը։ Ռեկուրսիան կազմակերպվում է ըստ `n`֊ի։ Եթե `n`֊ը զրո է կամ ցուցակը դատարկ է, ապա ռեկուրսիան ավարտվում է և ֆունկցիան վերադարձնում է դատարկ ցուցակ՝ `'()`։ Հակառակ դեպքում `l`֊ի առաջին տարրը կցվում է `l`-ի պոչից `n-1` հատ անջատված տարրերի սկզբից։

````lisp
(defun first-n (l n)
    (if (or (zerop n) (endp l))
        '()
        (cons (car l) (first-n (cdr l) (1- n)))))
````

Ահա նաև մի քանի օրինակ․

````lisp
(first-n '(1 2 3 4 5 6 7) 3)   ; => (1 2 3)
(first-n '(1 2 3 4 5 6 7) 2)   ; => (1 2)
(first-n '(1 2 3 4 5 6 7) 10)  ; => (1 2 3 4 5 6 7)
(first-n '() 10)               ; => NIL
````


__Հարց։__ Ինչպե՞ս է սահմանվում սովորական ֆունկցիան։

«Սովորական» (գլոբալ) ֆունկցիան սահմանվում է `defun` գործողության միջոցով։ `defun`֊ին պետք է փոխանցել ֆունկցիայի անունը, պարամետրերի ցուցակը և մարմինը ձևավորող արտահայտությունների հաջորդականությունը։ Օրինակ, աշխարհին հայերեն, ռուսերեն և իտալերեն ողջունող ֆունկցիայի սահմանումը կարող է լինել այսպիսին․

````lisp
(defun hello ()
    (princ "Ողջո՜ւյն, աշխարհ։ ")
    (princ "Привет, мир! ")
    (princ "Ciao, mondo!"))
````

Այս ֆունկցիայի անունը `hello` է, պարամետրերի ցուցակը դատարկ է՝ `()`, իսկ մարմինկ բաղկացած է երեք լեզուներոց տեքստն արտածող `princ` գործողություններից։

Եթե անհրաժեշտ է սահմանել


__Հարց։__ Ինչպե՞ս է սահմանվում ոչ֊պարտադիր պարամետրերով ֆունկցիան։

Ֆուկցայի պարամետրերի ցուցակը սահմանելիս `&optional` ծառայողական բառից հետո թվարկված պարամետրերը համարվում են _ոչ֊պարտադիր_։ Օրինակ, հետևյալ `f` ֆունկցիայում `x` պարամետրը պարտադիր է, իսկ `y`֊ը և `z`֊ը՝ ոչ։

````lisp
(defun f(x &optional y z)
    (list x y z))
````

Եթե ոչ֊պարտադիր պարամետրերով ֆունկցիան կանչվում է միայն պարտադիր պարամետրերի արժեքներով, ապա չտրված պարամետրերն ընդունում են `nil` արժեքը։ Ահա `f` ֆունկցիայի կիրառման մի քանի օրինակներ․

````lisp
(f 1)         ; => (1 nil nil)
(f 2 3)       ; => (2 3 nil)
(f 4 5 6)     ; => (4 5 6)
````

Ոչ֊պարտադիր պարամետրին կարելի է տալ _լռելության արժեք_, որն օգտագործվում է այն դեպքում, երբ ֆունկցիան կանչելի տվյալ պարամետրի արժեքը տրված չէ։ Օրինակ, հեետևյալ `h` ֆունկցիան սահմանված է `777` արժեքն ունեցող `y` ոչ֊պարտադիր պարամետրով․

````lisp
(defun h(x &optional (y 777))
    (list x y))
(h 22)       ; => (22 777)
(h 22 888)   ; => (22 888)
````


__Հարց։__ Ինչպե՞ս է սահմանվում անվանված պարամետրերով ֆունկցիան։

Անվանված պարամետրերով ֆունկցիա սահմանելու համար պարամետրերի ցուցակում օգտագործվում է `&key` ծառայողական բառը։ Երբ ֆունկցիան սահմանված է անվանված պարամետրերով, դրա կիրառության ժամանակ պետք է տալ նաև պարամետրի անունը։ Օրինակ, 


__Հարց։__ Ինչպե՞ս սահմանել վարիադիկ ֆունկցիա։




__Հարց։__ Ինչպե՞ս սահմանել լոկալ ֆունկցիա։

Ֆունկցիայի ներսում _լոկալ_ ֆունկցիան սահմանվում է `flet` և `labels` կառուցվածքներով։ `flet`֊ով սահմանված ֆունկցիան չի կարող կանչել ինքն իրեն, կամ նույն իր մակարդակում սահմանված մի այլ ֆունկցիայի։ `flet`֊ի միջոցով սահմանվում են 

Եթե հարկավոր են ռեկուրսիվ լոկալ ֆունկցիաներ, ապա օգտագործվում է `labels` կառուցվածքը։ Օրինակ, ցուցկը շրջող `reverse-it` ֆունկցիան սահմանելիս շատ հարմար է նրա ներսում սահմանել _վերջին կանչի ռեկուրսիայով_ լոկալ օժանդակ ֆունկցիա․

````lisp
(defun reverse-it (ls)
    (labels ((reverse-rec (l r)
        (if (endp l)
            r
            (reverse-rec (cdr l) (cons (car l) r)))))
        (reverse-rec ls '())))
````


__Հարց։__ Ինչպե՞ս սահմանել և օգտագործել անանուն ֆունկցիան։




__Հարց։__ Ինչպե՞ս սահմանել գլոբալ հաստատուն։

Գլոբալ հաստատունը, որի անունը, ի դեպ, ընդունված է սկսել և ավարտել `+` նիշով, սահմանվում է `defconstant` գործողությամբ։ Սա ստանում է հաստատունի անունը, արժեքը և ոչ֊պարտադիր նկարագրության տող։ Օրինակ․

````lisp
(defconstant +size+ 2048)   ; ինչ֊որ չափ ցույց տվող հաստատուն
(defconstant +name+ "Արմեն"
    "Իմ անունը որպես գլոբալ հաստատուն")
````


__Հարց։__ Ինչպե՞ս սահմանել գլոբալ (դինամիկ) փոփոխական։

Գլոբալ փոփոխականներ սահմանելու համար նախատեսված են `defvar` և `defparameter` գործողությունները։ Սրանք երկուսն էլ կատարման միջավայր են ներմուծում նոր անուն՝ դրան վերագրելուվ տրված սկզբնական արժեքը։ 


__Հարց։__ Ինչպե՞ս ստուգել ֆայլի գոյությունը։

`probe-file` ֆունկցիան տրված ֆայլի անունի համար վերադարձնում է համապատասխան `pathnam` նկարագրիչը, եթե ֆայլը գոյություն ունի։ Հակառակ դեպքում՝ վերադարձնում է `nil`։ Օրինակ․

````lisp
(probe-file "clnqa.md")  ; => #P"/home/armenba/Documents/clnqa/clnqa.md"
(probe-file "what.txt")  ; => nil
````


__Հարց։__ Ինչպե՞ս տող առ տող կարդալ տեքստային ֆայլը։

Տեքստային ֆայլից մեկ տող է կարդում `read-line` ֆունկցիան, որի առաջին արգումենտում պետք է տալ ֆայլային հոսքը։ Օրինակ, հետևյալ կոդը կարդում ու արտածում է `test0.txt` ֆայլի առաջին տողը․

````lisp
(with-open-file (inp "test0.txt")
    (print (read-line inp)))
````

Ֆայլը տող առ տող կարդալու համար կարելի է `read-line` գործողությունը կանչել ցիկլի մեջ։ Օրինակ, `loop` ցիկլի օգտագործմամբ․

````lisp
(with-open-file (inp "test0.txt")
    (loop for line = (read-line inp nil nil)
          until (nullp line)
          do (print line)))
````

Այստեղ `read-line`֊ի երկրորդ արգումենտում տրված `nil` արժեքը ցույց է տալիս, որ ֆայլի վերջին հասնելիս պետք է վերադարձնել `read-line`֊ի երրորդ արգումենտում տրված արժեքը (այս դեպքում՝ նորից `nil`)։ Եթե `read-line`֊ի երկրորդ արգումենտում `nil`֊ից տարբեր արժեք է, ապա, ֆայլի վերջին հասնելիս, գեներացվում է սխալ։

